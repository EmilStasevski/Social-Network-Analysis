---
title: 'DS Minor: Lab 03 -- Nets & Tests'
output: html_document
---

```{r}
library(dplyr)
library(igraph)
```


## Не только описание

> Анализ сетей не ограничивается описанием характеристик и рисованием графов

Анализ сетевых данных -- это не только визуализация (хотя это значительная часть), не только выявление важных вершин или выделение сообществ (хотя это может быть и основной задачей исследования). Например, можно выявлять взаимосвязи сетевых характеристик и других данных 

Вспомним про семьи Флоренции, которые мы загружали на самом первом занятии. Связь между семьями -- брачные договоры.

```{r}
adjFlorence <- read.csv("~/shared/minor2_2021/2-tm-net/lab01-netIntro/florentineFamily.csv")
rownames(adjFlorence) <- names(adjFlorence)
adjFlorence <- as.matrix.data.frame(adjFlorence)
```

Строим граф 

* почему используется функция graph.adjacency(), а не graph_from_dataframe()?

```{r message=F, warning=FALSE}
florentine <- graph.adjacency(adjmatrix = adjFlorence, mode = "undirected")
```

Потренируемся с другой визуализацией -- рисуем с помощью ggraph (материалы к сегодняшнему занятию)

```{r}
library(ggraph)
ggraph(florentine) + 
    geom_edge_link(alpha = 0.7) + 
    geom_node_point(size = 8)  +
    geom_node_label(aes(label=name))  +
    theme_void()
```


А теперь посмотрим на другую сеть про те же семьи Флоренции -- теперь с финансовыми связями.

```{r}
adjFlorenceFinance <- read.csv("~/shared/minor2_2021/2-tm-net/lab03-netTests/florentineFamilyFinance.csv")
rownames(adjFlorenceFinance) <- names(adjFlorenceFinance)

adjFlorenceFinance <- as.matrix.data.frame(adjFlorenceFinance)
```

> Подробный анализ связей семьи Медичи и история их прихода к власти хорошо описывается в статье (в том числе, и с )
Robust Action and the Rise of the Medici, 1400-1434 (John F. Padgett, and Christopher K. Ansell) 
https://www.journals.uchicago.edu/doi/abs/10.1086/230190


```{r message=F, warning=FALSE}
florentineFinance <- graph.adjacency(adjmatrix = adjFlorenceFinance, mode = "undirected")
```

```{r}
ggraph(florentineFinance) + 
    geom_edge_link(alpha = 0.7) + 
    geom_node_point(size = 8)  +
    geom_node_label(aes(label=name))  +
    theme_void()
```

Мы можем провести анализ и для этой сети -- посчитать центральности и найти важные вершины, выделить сообщества. 

* как узнать, какие вершины важные? 
    * У кого больше финансовых связей?
    * Что в этой сети содержательно значит "вершина с высокой битвинностью"?
    
```{r}
betweenness(florentineFinance)
```

Но что, если мы хотим сравнить эти сети? Попробуем нарисовать. ggraph умеет работать с facets, как и ggplot -- причем делить можно как по ребрам, так и по вершинам. Но для этого нам понадобится граф, на котором отображены связи сразу двух типов. Для этого сначала делаем обратное преобразование -- соберем из готовых сетей списки ребер

```{r}
edgelist1 = get.edgelist(florentine)
edgelist1 = edgelist1 %>% as.data.frame() %>% mutate(type = "marriage")
edgelist2 = get.edgelist(florentineFinance)
edgelist2 = edgelist2 %>% as.data.frame() %>% mutate(type = "finance")
all_el = rbind(edgelist1, edgelist2)

allGraph = graph_from_data_frame(all_el, 
                                 vertices = V(florentine)$name, 
                                 directed = F)

ggraph(allGraph) + 
    geom_edge_link(alpha = 0.7, aes(color = type)) + 
    geom_node_point(size = 8)  +
    geom_node_label(aes(label=name))  +
    facet_edges(~type) +
    theme_void()

```



Но мы можем сравнить и количественно, попробовать понять, насколько "связи взаимосвязаны", другими словами, верно ли, что те семьи, у которых больше деловых связей, с большей вероятностью будут иметь и брачные связи.

Для этого можно посчитать корреляцию (метрика, которая показывает согласованность двух переменных -- сетей в нашем случае). Обратите внимание: она вычисляется для матриц, не для объектов igraph, mode соответствует типу графа (graph для неориентированного, digraph для ориентированного)

Функции пакетов sna и igraph пересекаются и часто вызывают конфликты, поэтому отключим пакет igraph.

```{r message=F, warning=FALSE}
detach("package:igraph")
library(sna)
gcor(adjFlorenceFinance, adjFlorence, mode = "graph")
```

* Это много или мало?
* Есть взаимосвязь или нет?
* Может, это просто случайно так получилось? Может, просто сеть маленькая и каждая связь имеет большое значение?

Так же, как и для сравнений обычных переменных (средних, например), для ответов на такие вопросы про графы существуют специальные статистические тесты. 

Вспомним логику тестов: 

* предполагаем, что взаимосвязи нет 
* получаем распределение нужного нам параметра при таком предположении 
* сравниваем, выделяется ли наше реальное значение из этого множества случайных 
* если выделяется ("статистически значимо"), то отвергаем первоначальное предположение об отсутствии взаимосвязи
* если не выделяется, то наше реальное различие может быть получено и случайно

С графами логика такая же

* давайте будем генерировать графы случайно и посмотрим, сможем ли мы получить интересующую нас связь или нет
    * оставляем те же вершины, что есть в первоначальном графе
    * оставляем то же число связей 
    * но распределяем эти связи случайно
    * в терминах матрицы смежности: оставляем названия строк и столбцов и общее число единиц, но перемешиваем эти единицы по матрице случайно
* считаем для каждого такого графа корреляцию, повторяем много раз
* если наше реальное значение выделяется из массы случайных, то считаем, что взаимосвязь есть

В пакете sna есть специальная функция, которая реализует этот процесс "перемешаем-посчитаем". Только сначала нам нужно организовать из наших матриц единый объект. Т.е. это будет объект из двух элементов, каждый их которых является матрицей 16*16

```{r}
# соединяем две матрицы в один объект (список)
florTotal <- list(adjFlorence, adjFlorenceFinance)

# запускаем тест
set.seed(2223) # чтобы ответы совпали с расшифровкой ниже
flo.qap <- qaptest(florTotal, # матрицы, соответствующие сетям, соединенные в один объект
                   gcor, # функция, которую считаем
                   g1=1, g2=2, # объект может содержать больше двух матриц, 
                               # здесь указывается, какие именно матрицы используются
                   reps=1000) # сколько раз повторить
```

* florTotal - наши сети
* gcor - функция, значение которой мы будем вычислять
* g1, g2 - показатель того, что у нас два графа, которые нужно сравнить, в качестве первого используем первый элемент списка, в качестве второго - второй
* reps - число случайных графов

Смотрим на результат:

```{r}
summary(flo.qap)
```

	* `p(f(perm) >= f(d)):` = вероятность получить случайно (f(perm)) результат больше, чем посчитанный по выборке (f(d)) (соответствует p-value), при перезапусках это значение может немного отличаться 
	* `p(f(perm) <= f(d)):` = вероятность получить случайно (f(perm)) результат меньше, чем посчитанный по выборке (f(d)) (соответствует 1-p-value) 
	* `Test Value (f(d)): 0.3718679 ` = посчитанное по выборке значение корреляции 
	* `Replications: 1000` = число построенных случайно графов 
	* `Distribution Summary` = как распределены значения в случайно сгенерированной выборке. Они всегда будут распределены вокруг 0, но по ним можно еще перепроверить выводы. Например, в нашем случае максимальное значение, полученное случайно `Max:	 0.3042555 ` меньше, чем то, что получено по выборке `Test Value (f(d)): 0.3718679`, т.е. случайно получить такое значение невозможно согласно тесту.
	
	
То же самое можно еще раз посмотреть на графике плотности полученного распределения при случайной генерации графов

```{r}
plot(flo.qap)
```

```{r}

# запускать две строчки вместе
plot(flo.qap, xlim = c(-0.25, 0.4))
abline(v = 0.37, col = "blue")
```

**Ваша очередь!**

Загрузите данные о переписке в небольшой  IT-компании, проводящей маркетинговые исследования на R. Данные содержат две матрицы 17х17 с направленными связями.

* help_seeking.csv -- связь A->B в сети означает, что A отправил запрос B с просьбой проверить код на адекватность, чтобы позднее отправить заказчику.
* feedback.csv -- в этой сети связь B->A означает, что B ответил и оставил рецензию на код A.

```{r}
help_seeking <- read.csv("~/shared/minor2_2021/2-tm-net/lab03-netTests/help_seeking.csv")
feedback <- read.csv("~/shared/minor2_2021/2-tm-net/lab03-netTests/feedback.csv")
```

* Сформулируйте гипотезу о связи между двумя сетями, которую можно проверить с помощью корреляции, и проверьте ее

```{r}
gcor(help_seeking, feedback, mode = "graph")

# соединяем две матрицы в один объект (список)
total <- list(help_seeking, feedback)

# запускаем тест
set.seed(2223) # чтобы ответы совпали с расшифровкой ниже
flo.qap <- qaptest(...)

summary(flo.qap)
```


### Ассортативность

Для исследования структурных свойств сетей также можно оценить показатель **ассортативности или гомофилии**, т.е. того, насколько узлы склонны иметь связи с узлами, обладающими сходными свойствами. В этом случае мы уже добавляем в анализ не только сетевые, структурные характеристики (степень, битвинность и т.д.), но и какие-то внешние атрибуты (например, принадлежность к группе)

Напомним, что функции пакетов sna и igraph пересекаются и часто вызывают конфликты, поэтому в этот раз отключим пакет sna, т.к. нам понадобится igraph.

```{r message=F, warning=FALSE}
detach("package:sna")

library(igraph)
```
Загрузите данные о переписке в небольшой  IT-компании, проводящей маркетинговые исследования на R. Данные содержат две матрицы 17х17 с направленными связями.

* help_seeking.csv -- связь A->B в сети означает, что A отправил запрос B с просьбой проверить код на адекватность, чтобы позднее отправить заказчику.
* feedback.csv -- в этой сети связь B->A означает, что B ответил и оставил рецензию на код A.

```{r}
help_seeking <- read.csv("~/shared/minor2_2021/2-tm-net/lab03-netTests/help_seeking.csv")
feedback <- read.csv("~/shared/minor2_2021/2-tm-net/lab03-netTests/feedback.csv")
```

Преобразуем сети в igraph объекты

* как из матриц смежности можно получить объекты igraph?

Дополнительно загрузим файл с атрибутами узлов -- attr, включающем имя (name), пол (sex), образование (education), уровень экспертизы (предположим, что знание R сотрудниками компании было зафиксировано и выражено в численной переменной expertise). 

```{r}
g_feedback = graph.adjacency(as.matrix(feedback))
g_help_seeking = graph.adjacency(as.matrix(help_seeking))
attr = read.csv("~/shared/minor2_2021/2-tm-net/lab03-netTests/attr.csv")
```

Добавим атрибуты к узлам сети
```{r}
V(g_help_seeking)$name
V(g_help_seeking)$expertise = attr$expertise
V(g_help_seeking)$sex = factor(attr$sex)
V(g_help_seeking)$expertise = attr$expertise
V(g_help_seeking)$education = factor(attr$education)
```

```{r}
ggraph(g_help_seeking) + 
    geom_edge_link(alpha = 0.5) + 
    geom_node_point(size = 8, aes(color = factor(sex)))  +
    geom_node_text(aes(label=name))  +
    theme_void()
```


Посчитаем коэффициент ассортативности
```{r}
assortativity_nominal(g_help_seeking, V(g_help_seeking)$sex, directed = T)
```

Итак, мы получили коэффициент ассортативности. Он измеряется от -1 до 1, где -1 -- связи в сети склонны формироваться между узлами с отличающимися характеристиками, а 1 -- узлы предпочитают формировать связь с похожими узлами (в нашем случае, схожие по полу), 0 -- связи формируются без привязки к этой характеристике 

Также можем посчитать ассортативность для непрерывной переменной (обратите внимание на название функции)
```{r}
assortativity(g_help_seeking, V(g_help_seeking)$expertise, directed = T)
```

* есть ли склонность образовывать связи с людьми, схожими по уровню знания R?

Насколько мы можем быть уверены в этом ответе? А что, если при отсутствии реальной взаимосвязи мы получим похожий результат? *Звучит знакомо, да?* Опять используем статистические тесты. 

Посмотрим на примере с полом. Предполагаем, что пол распределяется случайно -> перемешиваем, пересчитываем -> сравниваем, делаем выводы = знакомый тест перестановок

```{r}
g = g_help_seeking
number_of_permutations = 2000
assortativity_shuffled  <- rep(NA, number_of_permutations)
for(i in 1:number_of_permutations){
  V(g)$attr_shuffled = sample(V(g)$sex, replace = F)
  assortativity_shuffled[i] = assortativity_nominal(g,as.factor(V(g)$attr_shuffled))
}
```

Квантили при случайном перемешивании
```{r}
q <- quantile(assortativity_shuffled, c(0.05, 0.95))
q
```

Реальная ассортативность
```{r}
assortativity_real = assortativity_nominal(g, V(g)$sex, directed = T)
assortativity_real
```
p-value
```{r}
pvalue = sum(abs(assortativity_shuffled) >= abs(assortativity_real)) / number_of_permutations
pvalue
```

И можно график нарисовать
```{r}
library(ggplot2)
df <- data.frame(assortativity_shuffled = assortativity_shuffled) 
ggplot(df) +
  geom_histogram(aes(assortativity_shuffled), fill="lightgreen") + 
  geom_vline(xintercept=assortativity_real, color="black")+ 
  geom_vline(xintercept=q[1], color="red") +
  geom_vline(xintercept=q[2], color="red") + theme_bw()


```

* Выводы?

**Ваша очередь**

Посмотрите, насколько работники склонны просить рецензии у "равных" по уровню образования 
```{r}

```

Повторите на сети feedback
```{r}
plot(g_feedback)
```


